<?php
/**
 * This file is auto generated from the `wp-bundler` cli. The AutoLoader class
 * is supposed to be used to load assets generated by the wp-bundler cli.
 *
 * This file should be ignored by your version control system, e.g. git.
 *
 * @package WPBundler
 * @author  Adam Bergman <adam@fransvilhelm.com>
 * @license MIT https://opensource.org/licenses/MIT
 * @version v0.0.0
 * @link    https://github.com/adambrgmn/wp-bundler
 * @since   0.0.1
 */

namespace WPBundler;

/**
 * Core class to register and enqueue assets generated by the wp-bundler cli.
 *
 * @package WPBundler
 * @author  Adam Bergman <adam@fransvilhelm.com>
 * @license MIT https://opensource.org/licenses/MIT
 * @link    https://github.com/adambrgmn/wp-bundler
 * @since   0.0.1
 */
class AssetLoader
{
    /**
     * Indicates if the loader is prepared yet. To avoid doubles.
     *
     * @since 0.0.1
     * @var bool
     */
    private static $prepared = false;

    /**
     * Domain used for translations.
     *
     * @since 0.0.1
     * @var string
     */
    private static $domain = 'domain';

    /**
     * Build directory, relative to template root directory.
     *
     * @since 0.0.1
     * @var string
     */
    private static $outdir = '/build/';

    /**
     * Assets generated by the cli.
     *
     * @since 0.0.1
     * @var array
     */
    private static $assets = [];

    /**
     * Prepare the asset loader by setting up required actions and filters. This
     * method should be called as early as possible.
     *
     * @since 0.0.1
     * @return void
     */
    public static function prepare(): void
    {
        if (self::$prepared) {
            return;
        }

        \add_filter(
            'script_loader_tag',
            function (string $tag, string $handle): string {
                if (!str_contains($handle, 'wp-bundler.')) {
                    return $tag;
                }

                if (str_contains($handle, '.nomodule')) {
                    return str_replace(' src', ' nomodule src', $tag);
                }

                return str_replace('text/javascript', 'module', $tag);
            },
            10,
            2
        );

        self::$prepared = true;
    }

    /**
     * Setup wp action and enqueue the scripts related to the provided handle.
     *
     * @since 0.0.1
     *
     * @param string $name     Name of asset to enqueue.
     * @param array  $deps     Optional. Dependecy array (e.g. jquery, wp-i18n etc.).
     * @param bool   $inFooter Optional. Wether to enqueue scripts in the footer (defaults to `true`).
     * @param string $action   Action to hook into (defaults to `'wp_enqueue_scripts'`).
     * @return void
     */
    public static function addAction(
        string $name,
        array $deps = [],
        bool $inFooter = true,
        string $action = 'wp_enqueue_scripts'
    ): void {
        self::prepare();
        \add_action($action, function () use ($name, $deps, $inFooter) {
            self::enqueue($name, $deps, $inFooter);
        });
    }

    /**
     * Enqueue assets with the `'enqueue_block_editor_assets'` wp action.
     *
     * @since 0.0.1
     *
     * @param string $name Name of asset to enqueue.
     * @param array  $deps Optional. Dependency array (e.g. jquery, wp-i18n etc.).
     * @return void
     */
    public static function enqueueEditorAssets(string $name, array $deps): void
    {
        self::prepare();
        self::addAction($name, $deps, true, 'enqueue_block_editor_assets');
    }

    /**
     * Register assets.
     *
     * @since 0.0.1
     *
     * @param string $name     Name of asset to register.
     * @param array  $deps     Optional. Dependency array (e.g. jquery, wp-i18n etc.).
     * @param bool   $inFooter Optional. Render script tag in footer (defaults to `true`).
     * @return array Returns array of registered handles by type (js, css, nomodule).
     */
    public static function register(
        string $name,
        array $deps = [],
        bool $inFooter = true
    ): array {
        $handles = [];

        if (!key_exists($name, self::$assets)) {
            return $handles;
        }

        $asset = self::$assets[$name];

        if (key_exists('js', $asset)) {
            $handle = 'wp-bundler.' . $name;
            $handles['js'] = $handle;

            \wp_register_script(
                $handle,
                self::outDirUri($asset['js']),
                array_merge($asset['deps'], $deps),
                false,
                $inFooter
            );

            \wp_set_script_translations(
                $handle,
                self::$domain,
                self::outDirPath('languages')
            );
        }

        if (key_exists('nomodule', $asset)) {
            $handle = 'wp-bundler.' . $name . '.nomodule';
            $handles['nomodule'] = $handle;

            \wp_register_script(
                $handle,
                self::outDirUri($asset['nomodule']),
                array_merge($asset['deps'], $deps),
                false,
                $inFooter
            );
        }

        if (key_exists('css', $asset)) {
            $handle = 'wp-bundler.' . $name;
            $handles['css'] = $handle;

            \wp_register_style(
                $handle,
                self::outDirUri($asset['css']),
                [],
                false,
                'all'
            );
        }

        return $handles;
    }

    /**
     * Enqueue assets.
     *
     * @since 0.0.1
     *
     * @param string $name     Name of asset to enqueue.
     * @param array  $deps     Optional. Dependency array (e.g. jquery, wp-i18n etc.).
     * @param bool   $inFooter Optional. Render script tag in footer (defaults to `true`).
     * @return array Returns array of registered handles by type (js, css, nomodule).
     */
    public static function enqueue(
        string $name,
        array $deps = [],
        bool $inFooter = true
    ): array {
        $handles = self::register($name, $deps, $inFooter);

        foreach ($handles as $key => $handle) {
            if ($key === 'css') {
                \wp_enqueue_style($handle);
            } else {
                \wp_enqueue_script($handle);
            }
        }

        return $handles;
    }

    /**
     * Register assets as related to a specific block type.
     *
     * @param string $name        Name of assets to register as part of the block
     * @param string $blockName   Name of the block to register
     * @param array  $blockConfig Optional. Array of block type arguments. Accepts any public property of `WP_Block_Type`. See WP_Block_Type::__construct() for information on accepted arguments. Default empty array.
     * @param array  $deps        Optional. Dependency array (e.g. jquery, wp-i18n etc.).
     * @return WP_Block_Type|false The registered block type on success, or false on failure.
     */
    public static function registerBlockType(
        string $name,
        string $blockName,
        array $blockConfig = [],
        array $deps = []
    ) {
        $handles = self::register($name, $deps);

        if (key_exists('js', $handles)) {
            $blockConfig['editor_script'] = $handles['js'];
        }

        if (key_exists('css', $handles)) {
            $blockConfig['editor_style'] = $handles['css'];
        }

        return \register_block_type($blockName, $blockConfig);
    }

    /**
     * Get full uri path to theme directory.
     *
     * @param string $path Path to append to theme directory uri
     * @return string
     */
    private static function outDirUri(string $path): string
    {
        return \get_template_directory_uri() . self::$outdir . $path;
    }

    /**
     * Get full path to theme directory.
     *
     * @param string $path Path to append to theme directory
     * @return string
     */
    private static function outDirPath(string $path): string
    {
        return \get_template_directory() . self::$outdir . $path;
    }
}
